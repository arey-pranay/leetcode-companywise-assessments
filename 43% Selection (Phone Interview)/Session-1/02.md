# Intuition

Version numbers are separated by dots `"."`, and each segment represents a numeric revision level.

To compare two versions:

* Compare each corresponding revision number from left to right.
* If one revision is greater than the other → return accordingly.
* If all compared revisions are equal, the longer version may still be greater **only if remaining revisions are non-zero**.
* Leading zeros don’t matter because we parse each segment as an integer.

---

# Approach

1. Split both version strings using `"\\."`.
2. Iterate through both arrays simultaneously:

   * Convert each segment to integer.
   * Compare them.
   * If different → return `1` or `-1`.
3. If one version still has remaining segments:

   * Check if any remaining segment is non-zero.
   * If yes → that version is greater.
4. If no differences found → return `0`.

---

# Complexity

* **Time complexity:**
  ( O(n + m) )
  Where `n` and `m` are the number of segments in `version1` and `version2`.

* **Space complexity:**
  ( O(n + m) )
  Due to storing split arrays.

---

# Code

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");        
        int i = 0;
        
        while (i < v1.length && i < v2.length) {
            int a = Integer.parseInt(v1[i]);
            int b = Integer.parseInt(v2[i]);
            
            if (a > b) return 1;
            else if (a < b) return -1;
            
            i++;
        }
        
        while (i < v1.length)
            if (Integer.parseInt(v1[i++]) > 0) return 1;
        
        while (i < v2.length)
            if (Integer.parseInt(v2[i++]) > 0) return -1;
        
        return 0;
    }
}
```

---

# Optional Optimization (Better Space)

You can reduce space complexity to **O(1)** by avoiding `split()` and parsing on the fly using two pointers. This avoids creating arrays and is often preferred in interviews.
