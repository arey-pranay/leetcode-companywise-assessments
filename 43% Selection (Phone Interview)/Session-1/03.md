## Intuition

We simulate manual multiplication (like we do on paper).
Each digit in `num1` multiplies with each digit in `num2`, and their product contributes to a specific position in the final result.

Instead of converting the strings to integers (which may overflow), we:

* Multiply digits from right to left.
* Store intermediate sums.
* Manage carry properly.
* Remove leading zeros at the end.

Your approach computes digits diagonal-wise (based on `d1 + d2 = diff`), which correctly models how digit contributions align in multiplication.

---

## Approach

1. Let:

   * `m = num1.length()`
   * `n = num2.length()`

2. The maximum possible length of the result is `m + n`.

3. For every possible diagonal (`diff` from `2` to `m+n+1`):

   * Find all pairs `(d1, d2)` such that:

     ```
     d1 + d2 == diff
     ```
   * Convert them to actual indices:

     ```
     i1 = m - d1
     i2 = n - d2
     ```
   * Multiply digits and accumulate into `temp`.

4. Add previous carry.

5. Append `temp % 10` to result.

6. Update `carry = temp / 10`.

7. Reverse the result and remove leading zeros.

---

## Complexity

* **Time complexity:**
  The nested loops effectively compute each pair of digits once.
  Worst case:

  ```
  O(m * n)
  ```

* **Space complexity:**
  Result string can be at most length `m + n`.

  ```
  O(m + n)
  ```

---

## Code

```java
class Solution {
    public String multiply(String num1, String num2) {
        int m = num1.length();
        int n = num2.length();
        int carry = 0;
        StringBuilder ans = new StringBuilder();

        for (int diff = 2; diff < m + n + 2; diff++) {
            int temp = 0;

            for (int d1 = 1; d1 < diff; d1++) {
                for (int d2 = 1; d2 < diff; d2++) {
                    if (d1 + d2 > diff) break;
                    if (d1 + d2 < diff) continue;

                    int i1 = m - d1;
                    int i2 = n - d2;

                    if (i1 < 0 || i2 < 0) continue;

                    temp += (num1.charAt(i1) - '0') * (num2.charAt(i2) - '0');
                }
            }

            temp += carry;
            ans.append(temp % 10);
            carry = temp / 10;
        }

        ans.reverse();

        int index = 0;
        int len = ans.length();
        while (index < len - 1 && ans.charAt(index) == '0') {
            index++;
        }

        return ans.substring(index);
    }
}
```

---

### ðŸ”Ž Optional Optimization

This solution works, but it can be simplified and made more efficient using a direct `int[] result = new int[m + n]` approach that avoids the triple nested iteration structure, or the cleaner O(mÂ·n) implementation.
