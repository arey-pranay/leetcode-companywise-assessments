## Intuition

To find the **Lowest Common Ancestor (LCA)** of two nodes `p` and `q` in a binary tree, think bottom-up:

* If a subtree contains **both `p` and `q`**, then its root is their LCA.
* If a subtree contains only **one of them**, we pass that node upward.
* If neither is found, return `null`.

So at each node:

* If it matches `p` or `q`, return it.
* Recursively search left and right.
* If both sides return non-null → current node is the LCA.
* Otherwise → return whichever side is non-null.

This works for a **general binary tree**, not necessarily a BST.

---

## Approach

1. **Base Case**

   * If `root == null`, return `null`.
   * If `root == p` or `root == q`, return `root`.

2. **Recursive Search**

   * Recursively search in the left subtree.
   * Recursively search in the right subtree.

3. **Determine LCA**

   * If both left and right results are non-null → current node is LCA.
   * If only one is non-null → return that one.
   * If both are null → return null.

This is a classic postorder traversal (Left → Right → Node).

---

## Complexity

* **Time complexity:**
  (O(n))
  Each node is visited once.

* **Space complexity:**
  (O(h))
  Due to recursion stack, where `h` is the height of the tree.
  Worst case (skewed tree): (O(n))
  Balanced tree: (O(\log n))

---

## Code

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        
        // Base case
        if (root == null || root == p || root == q) {
            return root;
        }

        // Search left and right
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        // If both sides are not null, root is LCA
        if (left != null && right != null) {
            return root;
        }

        // Otherwise return the non-null child
        return (left != null) ? left : right;
    }
}
```
